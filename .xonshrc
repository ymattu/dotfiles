import os
from collections import Counter

os.environ['EDITOR'] = "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"
os.environ['VISUAL'] = "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"

$DIR_HIST_PATH = "~/.dirhist"

$PATH.append("/usr/local/bin")
$PATH.append("/usr/local/texlive/2017/bin/x86_64-darwin")


"""
Âü∫Êú¨Ë®≠ÂÆö
"""
# viÈ¢®„ÅÆÊìç‰Ωú„Åå„Ç∑„Çß„É´‰∏ä„ÅßÁõ¥ÊÑüÁöÑ„Åß„Å™„ÅÑ„ÅÆ„ÅßFalse
$VI_MODE = False
# Ë£úÂÆå„ÇíEnter„ÅßÁõ¥Êé•ÂÆüË°å„Åó„Å™„ÅÑ
$COMPLETIONS_CONFIRM = True
# Ctrl + D „ÅßÁµÇ‰∫Ü„Åó„Å™„ÅÑ
$IGNOREEOF = True
# „Ç´„É©„Éº„ÉÜ„Éº„Éû
$XONSH_COLOR_STYLE = "native"
# tab„Åß„ÅØ„Å™„ÅèÁ©∫ÁôΩ4„Å§
$INDENT = "    "
# Ë£úÂÆåÊôÇ„Å´Â§ßÂ∞èÂå∫Âà•„Åó„Å™„ÅÑ
$CASE_SENSITIVE_COMPLETIONS = False
# ÈÄ£Á∂öÈáçË§á„Ç≥„Éû„É≥„Éâ„Çí‰øùÂ≠ò„Åó„Å™„ÅÑ
$HISTCONTROL = "ignoredups"
# Êã¨Âºß„ÇíË£úÂÆå
$XONSH_AUTOPAIR = True
# „Éá„Ç£„É¨„ÇØ„Éà„É™Âêç„ÇíÂÖ•Âäõ„Åô„Çå„Å∞cd„Åß„Åç„Çã
$AUTO_CD = True
# „Ç®„É©„ÉºÂÖ®„Å¶Âêê„Åè„Çà„ÅÜ„Å´
$XONSH_SHOW_TRACEBACK = True
# „Éó„É≠„É≥„Éó„Éà„ÅÆË®≠ÂÆö„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÊäëÂà∂
$SUPPRESS_BRANCH_TIMEOUT_MESSAGE = True
# „Ç≠„ÉºÂÖ•ÂäõÂç≥Ë©ï‰æ°
$UPDATE_COMPLETIONS_ON_KEYPRESS = True

# Ë¶ã„ÅüÁõÆ„ÇíÂ§âÊõ¥„Åô„Çã
# ÂèÇËÄÉ:http://xon.sh/tutorial.html#customizing-the-prompt
# ÂèÇËÄÉ:https://github.com/santagada/xontrib-powerline


#######powerline######
from os import path
from collections import namedtuple
from time import strftime


__all__ = ()

Section = namedtuple('Section', ['line', 'fg', 'bg'])

$PL_PARTS = 10
$PL_DEFAULT_PROMPT = 'short_cwd>rtns'
$PL_DEFAULT_RPROMPT = 'history>time'
$PL_DEFAULT_TOOLBAR = 'who>cwd>branch>virtualenv>full_proc'

$PL_PROMPT = "ymdhms>short_cwd"
$PL_RPROMPT = "!"
$PL_TOOLBAR = "who>cwd>branch>virtualenv>full_proc"


modes = {
    'powerline': '\ue0b0\ue0b1\ue0b2\ue0b3',
    'round': '\ue0b4\ue0b5\ue0b6\ue0b7',
    'down': '\ue0b8\ue0b9\ue0ba\ue0bb',
    'up': '\ue0bc\ue0bd\ue0be\ue0bf',
    'flame': '\ue0c0\ue0c1\ue0c2\ue0c3',
    'squares': '\ue0c6\ue0c4\ue0c7\ue0c5',
    'ruiny': '\ue0c8\ue0c1\ue0ca\ue0c3',
    'lego': '\ue0d1\ue0d0\ue0b2\ue0d0',
}

available_sections = {}
HOME = path.expanduser('~')


def alias(f):
    aliases[f.__name__] = f
    return f


def register_sec(f):
    available_sections[f.__name__] = f
    return f


@register_sec
def history():
    return Section(' %d ' % len(__xonsh_history__), 'WHITE', '#333')


@register_sec
def time():
    return Section(strftime(' %H:%M '), 'WHITE', 'BLUE')


@register_sec
def ymdhms():
    return Section(strftime(' %Y-%m-%d %H:%M:%S '), 'WHITE', '#0404B4')

@register_sec
def short_cwd():
    return Section(' {short_cwd} ', 'WHITE', '#333')


def compress_home(path):
    if path.startswith(HOME):
        path = '~' + path[len(HOME):]
    return path


@register_sec
def cwd():
    ps = compress_home($PWD).strip(os.sep).split(os.sep)

    if $PROMPT_FIELDS['curr_branch']():
        prefix = $(git rev-parse --show-prefix).strip()
        ni = -1  # the default is for empty prefix, which means the last directory is the root of the repository
        if prefix != '':  # this is the case that we are in a sub directory, so we try matching subdirectories
            subs = prefix.rstrip(os.sep).split(os.sep)
            for sub in reversed(subs):
                if ps[ni] != sub:
                    ni = 0
                    break
                ni -= 1
        if ni != 0:  # if ni ==0 subdirectory matching failed
            ps[ni] = '{BLUE}%s{WHITE}' % ps[ni]

    if len(ps) > $PL_PARTS:
        new_ps = [ps[0]]
        new_ps.append('‚Ä¶')
        new_ps += ps[-($PL_PARTS-1):]
        ps = new_ps

    ps_join = (' %s ' % $PL_SEP_THIN).join(ps)
    return Section(' %s ' % ps_join, 'WHITE', '#333')


@register_sec
def branch():
    if $PROMPT_FIELDS['curr_branch']():
        return Section(' ÓÇ†{curr_branch} ', '#333', $PROMPT_FIELDS['branch_bg_color']()[1+len('background_'):-1])


@register_sec
def virtualenv():
    if $PROMPT_FIELDS['env_name']():
        return Section(' üêç {env_name} ', 'INTENSE_CYAN', 'BLUE')


@register_sec
def rtns():
    if __xonsh_history__.rtns and __xonsh_history__.rtns[-1] != 0:
        return Section(' ! ', 'WHITE', 'RED')


@register_sec
def full_rtns():
    if __xonsh_history__.rtns:
        rtn = __xonsh_history__.rtns[-1]
        if rtn != 0:
            color = 'RED'
        else:
            color = '#444'

        return Section(' ' + str(rtn) + ' ', 'WHITE', color)


@register_sec
def timing():
    if __xonsh_history__.tss:
        tss = __xonsh_history__.tss[-1]

        return Section(' %.2fs ' % (tss[1] - tss[0]), 'WHITE', '#444')


@register_sec
def full_proc():
    if __xonsh_history__.buffer:
        lst = __xonsh_history__.buffer[-1]
        if lst['rtn'] != 0:
            color = 'RED'
        else:
            color = '#444'

        value = ' rtn: %d ts: %.2fs ' % (lst['rtn'], lst['ts'][1] - lst['ts'][0])
        return Section(value, 'WHITE', color)


@register_sec
def who():
    return Section(' {user}@{hostname} ', 'WHITE', '#555')


def prompt_builder(var, right=False):
    if var == '!':  # in case the prompt format is a single ! it means empty
        return ''

    pre_sections = []
    for e in var.split('>'):
        if e not in available_sections:
            print('section %s not found, skipping it' % e)
            continue
        pre_sections.append(available_sections[e])

    def prompt():
        p = []
        sections = []
        for s in pre_sections:
            # A section can be 2 things, a literal Section or a Function
            # and Functions can either return a Section of None if they are not part of prompt
            if isinstance(s, Section):
                sections.append(s)
            else:
                r = s()
                if r is not None:
                    sections.append(r)

        size = len(sections)
        for i, sec in enumerate(sections):
            last = (i == size-1)
            first = (i == 0)

            if right:
                p.append('{%s}%s{BACKGROUND_%s}{%s}%s' % (sec.bg, $PL_RSEP, sec.bg, sec.fg, sec.line))
            else:
                if first:
                    p.append('{BACKGROUND_%s}' % sec.bg)
                p.append('{%s}%s' % (sec.fg, sec.line))
                if last:
                    p.append('{NO_COLOR}{%s}%s{NO_COLOR} ' % (sec.bg, $PL_SEP))
                else:
                    p.append('{BACKGROUND_%s}{%s}%s' % (sections[i+1].bg, sec.bg, $PL_SEP))
        return ''.join(p)
    return prompt


@alias
def pl_set_mode(args):
    if len(args) != 1 or args[0] not in modes:
        print('you need to select a mode from:')
        for mode, seps in modes.items():
            print('%s: %s' % (mode, ', '.join(seps)))
        return
    seps = modes[args[0]]
    $PL_SEP, $PL_SEP_THIN, $PL_RSEP, _ = seps


@alias
def pl_available_sections():
    for name in available_sections.keys():
        r = prompt_builder(name)()
        f = __xonsh_shell__.prompt_formatter(r)
        __xonsh_shell__.print_color('%s: %s' % (name, f))


@alias
def pl_build_prompt():
    pl_set_mode(['powerline'])
    for var in 'PROMPT RPROMPT TOOLBAR'.split():
        varname = 'PL_' + var
        defname = 'PL_DEFAULT_' + var
        if varname not in __xonsh_env__:
            __xonsh_env__[varname] = __xonsh_env__[defname]

    $PROMPT = prompt_builder($PL_PROMPT)
    $BOTTOM_TOOLBAR = prompt_builder($PL_TOOLBAR)
    $RIGHT_PROMPT = prompt_builder($PL_RPROMPT, True)
    $TITLE = '{current_job:{} | }{cwd_base} | {user}@{hostname}'
    $MULTILINE_PROMPT = 'ÓäÖ'
pl_build_prompt()
###################################


# ls„Ç≥„Éû„É≥„Éâ„ÅÆÁµêÊûú„ÅÆË¶ã„ÅüÁõÆ
$LS_COLORS="di=34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30"
# „Éë„ÉØ„Éº„É©„Ç§„É≥„ÅÆË™≠„ÅøËæº„Åø
# xontrib load powerline

# „Ç®„Ç§„É™„Ç¢„Çπ
aliases["lt"] = "ls -ltr"
aliases["l"] = "ls -ltr"
aliases["la"] = "ls -la"
aliases["ll"] = "ls -l"
aliases["es"] = "exec $SHELL"
aliases["emacsclient"] = "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"
aliases["ec"] = "emacsclient ~/dotfiles/.xonshrc"
aliases["ez"] = "emacsclient ~/dotfiles/.zshrc"
aliases["eb"] = "emacsclient ~/dotfiles/.bashrc"
aliases["cp"] = "cp -i"
aliases["rm"] = "rm -i"
aliases["jn"] = "jupyter notebook"
aliases["jl"] = "jupyter lab"
aliases["fish"] = "/usr/local/bin/fish"
aliases["julia"] = "/Applications/Julia-1.0.app/Contents/Resources/julia/bin/julia"
aliases["juliaold"] = "/Applications/Julia-0.6.app/Contents/Resources/julia/bin/julia"

import json
from collections import OrderedDict
from operator import itemgetter


# Â±•Ê≠¥„Çípeco„Å´ÊµÅ„Åô
# https://qiita.com/riktor/items/4a90b4e125cd091a9d07
# peco„ÅÆinstall : https://qiita.com/ngyuki/items/94a7e638655d9910971b
def get_history(session_history=None, return_list=False):
    hist_dir = __xonsh_env__['XONSH_DATA_DIR']
    files = [ os.path.join(hist_dir,f) for f in os.listdir(hist_dir)
              if f.startswith('xonsh-') and f.endswith('.json') ]
    file_hist = [ json.load(open(f))['data']['cmds'] for f in files ]
    cmds = [ ( c['inp'].replace('\n', ''), c['ts'][0] )
                 for cmds in file_hist for c in cmds if c]
    cmds.sort(key=itemgetter(1))
    cmds = [ c[0] for c in cmds[::-1] ]
    if session_history:
        cmds.extend(session_history)
    # dedupe
    zip_with_dummy = list(zip(cmds, [0] * len(cmds)))[::-1]
    cmds = list(OrderedDict(zip_with_dummy).keys())[::-1]
    if return_list:
        return cmds
    else:
        return '\n'.join(cmds)

# ssh„Çípeco„Å´ÊµÅ„Åô
def get_ssh():
    items = re.sub(r'(?i)host ', '', $(cat ~/.ssh/config /etc/ssh/ssh_config | grep -i '^host'))
    return items


# „Ç≠„Éº„Éê„Ç§„É≥„Éâ
from prompt_toolkit.keys import Keys
from prompt_toolkit.filters import (Condition, IsMultiline, HasSelection, EmacsInsertMode, ViInsertMode)
@events.on_ptk_create
def custom_keybindings(bindings, **kw):
    # ptk 2.x„Åß„ÅØ‰∏çË¶Å
    handler = bindings.registry.add_binding

    # ptk 2.x„Åß„ÅØ @bindings.add('c-v') „Å®„Åô„Çã
    # „Ç≥„Éû„É≥„ÉâÂÖ•Âäõ‰∏≠„Å´ctrl+v„ÅßvimÁ∑®ÈõÜ
    @handler(Keys.ControlV)
    def edit_in_editor(event):
        event.current_buffer.tempfile_suffix = '.py'
        event.current_buffer.open_in_editor(event.cli)

    # ctrl+r„ÅßÂ±•Ê≠¥„Çípeco„Å´ÊµÅ„Åó„Å¶Ê§úÁ¥¢
    @handler(Keys.ControlR)
    def select_history(event):
        sess_history = $(history).split('\n')
        hist = get_history(sess_history)
        selected = $(echo @(hist) | peco)
        event.current_buffer.insert_text(selected.strip())

    # ctrl+s„ÅßsshÂÖà„Çípeco
    @handler(Keys.ControlS)
    def select_ssh(event):
        hosts = '\n'.join([x for x in get_ssh().split('\n') if x!='*' and 'HostKey' not in x])
        selected = $(echo @(hosts) | peco)
        if selected:
            event.current_buffer.insert_text('ssh ' + selected.strip())


# Áõ¥Ëøë„ÅÆxonshjob„Åì„Çç„Åô
# https://github.com/zardus/xonshrc/blob/master/xonshrc
def _kill_last(args, stdin=None):
        if __xonsh_active_job__ is None:
                print("No active job. Aborting.")
                return
        cmd = 'kill %s %d' % (''.join(args), __xonsh_all_jobs__[__xonsh_active_job__]['pgrp'])
        os.system(cmd)
aliases['kill_last'] = _kill_last

# diskutil info„ÇíË¶ã„Çã
# https://github.com/asmeurer/dotfiles/blob/master/.xonshrc
def _free(args, stdin=None):
    disk_info = $(diskutil info /)
    return [i for i in disk_info.splitlines() if "Free" in i][0] + '\n'
aliases['fr'] = _free

# „É©„Ç§„Éñ„É©„É™„ÅÆÂÆüË°åÊôÇimport
# https://vaaaaaanquish.hatenablog.com/entry/2017/12/26/190153
# xonsh‰∏ä„Åß‰Ωø„ÅÜ„Å®„Åç„Åå„ÅÇ„Çä„Åù„ÅÜ„Å™„É©„Ç§„Éñ„É©„É™„ÅØlazyasd„ÅßË£úÂÆåÊôÇ„ÄÅÂÆüË°åÊôÇ„Å´Ë™≠„ÅøËæº„Åø
from xonsh.lazyasd import lazyobject
import importlib
lazy_module_dict = {
    'sys': 'sys',
    'random': 'random',
    'shutil': 'shutil',
    'pd': 'pandas',
    'np': 'numpy',
    'requests': 'requests',
    'os': 'os',
    'plt': 'matplotlib.pyplot',
    'Path': 'pathlib.Path',
        }
for k,v in lazy_module_dict.items():
    t = "@lazyobject\ndef {}():\n    return importlib.import_module('{}')".format(k, v)
    exec(t)


"""
xontrib
"""
import xonsh.tools
import backtrace
import sys

# backtrace„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ_flush()„ÇíOverride
# ÂÖÉ„Ç≥„Éº„Éâ : https://github.com/nir0s/backtrace/blob/f2c8683ec53e4fa48ea8c99c196b201bf22fda3e/backtrace.py#L36
def __flush(message):
    st = message + '\n'
    sys.stderr.buffer.write(st.encode(encoding="utf-8"))
backtrace._flush=__flush

# xonsh„ÅÆprint_exception()„ÇíOverride
# ÂÖÉ„Ç≥„Éº„Éâ : https://github.com/xonsh/xonsh/blob/230f77b2bc64cbc3e04837377252793f5d09b9ba/xonsh/tools.py#L798
def _print_exception(msg=None):
    tpe, v, tb = sys.exc_info()
    backtrace.hook(tb=tb, tpe=tpe, value=v)
    if msg:
        msg = msg if msg.endswith('\n') else msg + '\n'
        sys.stderr.write(msg)
xonsh.tools.print_exception = _print_exception

from colorama import init, Fore, Style
STYLES = {
    'backtrace': Fore.YELLOW + '{0}',
    'error': Fore.RED + Style.BRIGHT + '{0}',
    'line': Fore.RED + Style.BRIGHT + '{0}',
    'module': '{0}',
    'context': Style.BRIGHT + Fore.GREEN + '{0}',
    'call': Fore.RED + '--> ' + Fore.YELLOW + Style.BRIGHT + '{0}',
}
backtrace.hook(reverse=True, strip_path=True, styles=STYLES)

